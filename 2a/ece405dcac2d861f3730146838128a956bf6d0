From tuhs-bounces@minnie.tuhs.org Mon Oct 29 10:02:57 2018
Return-Path: tuhs-bounces@minnie.tuhs.org
X-Spam-Checker-Version: SpamAssassin 3.4.2 (2018-09-13) on inbox.vuxu.org
X-Spam-Level: 
X-Spam-Status: No, score=-0.8 required=5.0 tests=DKIM_SIGNED,DKIM_VALID,
	DKIM_VALID_AU,HEADER_FROM_DIFFERENT_DOMAINS,HTML_MESSAGE,
	MAILING_LIST_MULTI,RCVD_IN_DNSWL_NONE autolearn=ham autolearn_force=no
	version=3.4.2
Received: from minnie.tuhs.org (minnie.tuhs.org [45.79.103.53])
	by inbox.vuxu.org (OpenSMTPD) with ESMTP id 676cfa86
	for <ml@inbox.vuxu.org>;
	Mon, 29 Oct 2018 10:02:56 +0000 (UTC)
Received: by minnie.tuhs.org (Postfix, from userid 112)
	id C0BDEA21CB; Mon, 29 Oct 2018 20:02:55 +1000 (AEST)
Received: from minnie.tuhs.org (localhost [127.0.0.1])
	by minnie.tuhs.org (Postfix) with ESMTP id E7AA0A1FD7;
	Mon, 29 Oct 2018 20:02:08 +1000 (AEST)
Received: by minnie.tuhs.org (Postfix, from userid 112)
 id 96046A1FB5; Mon, 29 Oct 2018 19:03:33 +1000 (AEST)
X-Greylist: delayed 21763 seconds by postgrey-1.35 at minnie.tuhs.org;
 Mon, 29 Oct 2018 19:03:27 AEST
Received: from pdx1-sub0-mail-fallback-a1.dreamhost.com
 (pdx1-sub0-mail-fallback-a1.dreamhost.com [64.90.62.138])
 by minnie.tuhs.org (Postfix) with ESMTPS id 97FA4A1FB0
 for <tuhs@tuhs.org>; Mon, 29 Oct 2018 19:03:27 +1000 (AEST)
Received: from homiemail-a57.g.dreamhost.com (peon1914.sd.dreamhost.com
 [10.50.0.93])
 (using TLSv1.1 with cipher AECDH-AES256-SHA (256/256 bits))
 (No client certificate requested)
 by pdx1-sub0-mail-fallback-a1.dreamhost.com (Postfix) with ESMTPS id
 73E8E276325
 for <tuhs@tuhs.org>; Sun, 28 Oct 2018 20:00:44 -0700 (PDT)
Received: from homiemail-a57.g.dreamhost.com (localhost [127.0.0.1])
 by homiemail-a57.g.dreamhost.com (Postfix) with ESMTP id DABA76003D09;
 Sun, 28 Oct 2018 20:00:42 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha1; c=relaxed; d=yaccman.com; h=message-id
 :from:to:in-reply-to:subject:date:content-type:mime-version; s=
 yaccman.com; bh=UUzyjHUQeLVu/B+4zd0jzdY0FBA=; b=lmZn/EZ0ba2QNuVg
 TwUlTOWXcb7znA+OY6iZ/QMZp2xHoZvBAMZGOv5ToG7WO1aAxzh3ZX5DO9ACF3SF
 7bETe4GWLsZUtQHbWBynX0Z448PmGOq+k21XXTKczoyVrE98XIn7nv+b3MqFsXVA
 pYGv1NaGD0HeF4RQ8yyKUd60AOE=
Received: from localhost (ip-66-33-200-4.dreamhost.com [66.33.200.4])
 (using TLSv1 with cipher ECDHE-RSA-AES256-SHA (256/256 bits))
 (No client certificate requested)
 (Authenticated sender: scj@yaccman.com)
 by homiemail-a57.g.dreamhost.com (Postfix) with ESMTPSA id A6A826000E37;
 Sun, 28 Oct 2018 20:00:42 -0700 (PDT)
Message-Id: <1dbc3d888e7be7a2c93e497eac14bcd9f43c72fc@webmail.yaccman.com>
From: "Steve Johnson" <scj@yaccman.com>
To: "Lars Brinkhoff" <lars@nocrew.org>,
 tuhs@tuhs.org
X-Mailer: Atmail 7.8.0.2
X-Originating-IP: 10.35.42.211
in-reply-to: <7wsh0piwli.fsf@junk.nocrew.org>
Date: Sun, 28 Oct 2018 20:00:42 -0700
Content-Type: multipart/alternative;
 boundary="=_47dde88ae27961fafbc113e2e4a30cc6"
MIME-Version: 1.0
Subject: Re: [TUHS] Archaic yacc C grammar
X-BeenThere: tuhs@minnie.tuhs.org
X-Mailman-Version: 2.1.20
Precedence: list
List-Id: The Unix Heritage Society mailing list <tuhs.minnie.tuhs.org>
List-Unsubscribe: <https://minnie.tuhs.org/cgi-bin/mailman/options/tuhs>,
 <mailto:tuhs-request@minnie.tuhs.org?subject=unsubscribe>
List-Archive: <http://minnie.tuhs.org/pipermail/tuhs/>
List-Post: <mailto:tuhs@minnie.tuhs.org>
List-Help: <mailto:tuhs-request@minnie.tuhs.org?subject=help>
List-Subscribe: <https://minnie.tuhs.org/cgi-bin/mailman/listinfo/tuhs>,
 <mailto:tuhs-request@minnie.tuhs.org?subject=subscribe>
Errors-To: tuhs-bounces@minnie.tuhs.org
Sender: "TUHS" <tuhs-bounces@minnie.tuhs.org>

--=_47dde88ae27961fafbc113e2e4a30cc6
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

=0AI don't recognize this as any Yacc that my hands have touched.=C2=A0=
=C2=A0=C2=A0=0ALooking at the reserved words,=0Athere is one, ENTRY, tha=
t I've never heard of (although FORTRAN had an=0AENTRY statement), =0A=
=0Aand there is STRUCT but no UNION.=C2=A0 Also, he uses val=3D instead=
 of=0A$$=3D.=C2=A0 There don't seem to be =0A=0Aany nontrivial assignmen=
t ops (neither +=3D or =3D+).=0A=0AAl was at Bell Labs in 1973, and this=
 is dated 5 years later.=0A=0AThe use of quotes for single character lit=
erals was in early Yaccs,=0Abut it led to some strange-looking =0A=0Alex=
ical analyzer code, and I quickly gave it up.=0A=0AI'm guessing either A=
l wrote it from scratch or based it on some other=0Asimilar program.=C2=
=A0 LR parsing=0Amade quite a stir in the 70's.=0A=0ACan't help you thou=
gh as far as how to generate a parser from this=0Ainput...=0A=0ASteve=0A=
=0A----- Original Message -----=0AFrom: "Lars Brinkhoff" <lars@nocrew.or=
g>=0ATo:<tuhs@tuhs.org>=0ACc:=0ASent:Sun, 28 Oct 2018 21:34:49 +0000=0AS=
ubject:[TUHS] Archaic yacc C grammar=0A=0A Hello,=0A=0A This is Alan Sny=
der's C grammar. It's supposedly for yacc, but it's=0A probably using so=
me really ancient version. Maybe from when Alan did=0Aa=0A stint at Bell=
 labs and converted yacc from B to C.=0A=0A Does anyone recognize this t=
ype of yacc input? I don't have the=0A corresponding yacc version, and t=
he one in V6 isn't happy about this=0A file. What would it take to updat=
e the grammar for V6 yacc? Add in=0A some %term, replace  with %%?=0A=0A=
 # C GRAMMAR #=0A # 28 May 1978 #=0A # Alan Snyder #=0A=0A # 26 acceptab=
le conflicts:=0A=0A 2 S/R conflicts for (parsing) ambiguity between=0A d=
eclarators and function_declarators=0A 1 S/R conflict for the C ELSE amb=
iguity=0A 4 R/R conflicts for the (parsing) problem with regard=0A to in=
teger constants as initial_values=0A 12 R/R conflicts for the (parsing)=
 problem with regard=0A to identifiers in function calls=0A 1 R/R confli=
ct for the (parsing) problem with regard=0A to identifiers in goto state=
ments=0A 4 R/R conflicts and 1 S/R conflict for TYPEDEFs=0A 1 S/R confli=
ct for ambiguous cast types=0A (int ()) =3D (int x()) not (int (x))=0A=
=0A Approximate description:=0A=0A 18 S/R ( shift 37 reduce 141=0A 50 S/=
R ( shift 37 reduce 71=0A 81 S/R ( shift 37 reduce 71=0A 113 R/R ( reduc=
e 141 reduce 140=0A 113 R/R ( reduce 159 reduce 140=0A 113 R/R * reduce=
 159 reduce 141=0A 113 S/R : shift 199 reduce 141=0A 183 R/R , reduce 20=
3 reduce 24=0A 183 R/R } reduce 203 reduce 24=0A 204 R/R ( reduce 159 re=
duce 140=0A 206 R/R ( reduce 148 reduce 139=0A 207 R/R ( reduce 147 redu=
ce 139=0A 208 R/R ( reduce 145 reduce 139=0A 209 R/R ( reduce 144 reduce=
 139=0A 210 R/R ( reduce 146 reduce 139=0A 211 R/R ( reduce 149 reduce 1=
39=0A 212 R/R ( reduce 150 reduce 139=0A 215 R/R ( reduce 159 reduce 140=
=0A 215 R/R ; reduce 159 reduce 138=0A 225 R/R ( reduce 151 reduce 139=
=0A 228 R/R ( reduce 159 reduce 140=0A 284 R/R , reduce 203 reduce 25=0A=
 284 R/R } reduce 203 reduce 25=0A 291 S/R ) shift 339 reduce 165=0A 343=
 R/R ( reduce 153 reduce 139=0A 360 S/R ELSE shift 369 reduce 94=0A=0A #=
=0A=0A # terminal symbols #=0A=0A ';' '}' '{' ']' '[' ')' '(' ':'=0A ','=
 '.' '?' '~' '!' '&' '|' '^'=0A '%' '/' '*' '-' '+' '=3D' '<' '>'=0A '++=
' '--' '=3D=3D' '!=3D' '<=3D' '>=3D' '<<' '>>'=0A '->' '=3Dop' '&&' '||'=
 'c'=0A INT CHAR FLOAT DOUBLE STRUCT AUTO STATIC=0A EXTERN RETURN GOTO I=
F ELSE SWITCH=0A BREAK CONTINUE WHILE DO FOR DEFAULT CASE=0A ENTRY REGIS=
TER SIZEOF LONG SHORT UNSIGNED TYPEDEF 'l'=0A 'm' 'n' 'o' 'p' 'q' 'r' 's=
'=0A identifier integer floatcon string=0A=0A # precedence information #=
=0A=0A < ','=0A > '=3D' '=3Dop'=0A > '?' ':'=0A < '||'=0A < '&&'=0A < '|=
'=0A < '^'=0A < '&'=0A < '=3D=3D' '!=3D'=0A < '<' '>' '<=3D' '>=3D'=0A <=
 '<<' '>>'=0A < '+' '-'=0A < '*' '/' '%'=0A > '!' '~'=0A > '++' '--' SIZ=
EOF=0A < '[' '(' '.' '->'=0A=0A =0A=0A # external definitions #=0A=0A pr=
ogram:=0A program external_definition=0A |=0A=0A external_definition:=0A=
 declaration=0A | function_definition=0A=0A function_definition:=0A func=
tion_specification function_body {afdef(#1,#2);}=0A=0A function_specific=
ation:=0A decl_specifiers function_declarator {val=3Dafdcl(1);}=0A | fun=
ction_declarator {val=3Dafdcl(0);}=0A=0A function_body:=0A formal_declar=
ations compound_statement {val=3D#2;}=0A=0A formal_declarations:=0A form=
al_decl_list {afpdcl();}=0A | {afpdcl();}=0A=0A compound_statement:=0A b=
egin declaration_list statement_list end {val=3D#3;}=0A | begin statemen=
t_list end {val=3D#2;}=0A=0A init_declarator_list:=0A init_declarator=0A=
 | init_declarator_list ',' init_declarator =0A=0A init_declarator:=0A $=
declarator initializer {aidecl();}=0A | declarator {aidecl();}=0A | func=
tion_declarator {adeclr(maktyp());}=0A=0A initializer:=0A initial_value=
=0A | '{' initial_value_expression_list '}'=0A | '{' initial_value_expre=
ssion_list ',' '}'=0A=0A initial_value_expression_list:=0A initial_value=
_expression=0A | initial_value_expression_list ',' initial_value_express=
ion=0A=0A initial_value:=0A integer {inz(i_int,#1);}=0A | '-' integer {i=
nz(i_int,-#2);}=0A | floatcon {inz(i_float,#1);}=0A | '-' floatcon {inz(=
i_negfloat,#2);}=0A | identifier {inz(i_idn,#1);}=0A | '&' identifier {i=
nz(i_idn,#2);}=0A | string {inz(i_string,#1);}=0A=0A initial_value_expre=
ssion:=0A constant {inz(i_int,#1);}=0A | initial_value=0A=0A # declarati=
ons #=0A=0A declaration_list:=0A declaration=0A | declaration_list decla=
ration=0A=0A declaration:=0A decl_specifiers init_declarator_list ';'=0A=
 | literal_type_specifier ';'=0A=0A decl_specifiers:=0A type_specifier {=
attrib(-1,#1);}=0A | sc_specifier type_specifier {attrib(#1,#2);}=0A | t=
ype_specifier sc_specifier {attrib(#2,#1);}=0A=0A type_specifier:=0A typ=
e_identifier=0A | literal_type_specifier=0A=0A literal_type_specifier:=
=0A INT {val=3DTINT;}=0A | CHAR {val=3DTCHAR;}=0A | FLOAT {val=3DTFLOAT;=
}=0A | DOUBLE {val=3DTDOUBLE;}=0A | LONG {val=3DTINT;}=0A | LONG INT {va=
l=3DTINT;}=0A | SHORT {val=3DTINT;}=0A | SHORT INT {val=3DTINT;}=0A | LO=
NG FLOAT {val=3DTDOUBLE;}=0A | UNSIGNED {val=3DTINT;}=0A | UNSIGNED INT=
 {val=3DTINT;}=0A | struct '{' type_decl_list '}' {val=3Dastruct(NULL,#3=
);}=0A | struct $identifier '{' type_decl_list '}' {val=3Dastruct(#2,#4)=
;}=0A | struct identifier {val=3Daostruct(#2);}=0A=0A sc_specifier:=0A A=
UTO {val=3Dc_auto;}=0A | STATIC {val=3Dc_static;}=0A | EXTERN {val=3Dc_e=
xtern;}=0A | REGISTER {val=3Dc_auto;}=0A | TYPEDEF {val=3Dc_typedef;}=0A=
=0A declarator_list:=0A declarator=0A | declarator_list ',' declarator=
 =0A=0A declarator:=0A dclr {val=3Dadeclr(maktyp());}=0A | identifier ':=
' constant {val=3Dadeclr(afield(#1,#3));}=0A | ':' constant {val=3Dadecl=
r(afield(-1,#2));}=0A=0A $declarator:=0A dclr {aiinz(adeclr(maktyp()));}=
=0A=0A dclr:=0A '*' dclr {val=3Dadclr(#2,MPTR);}=0A | dclr '(' ')' {val=
=3Dadclr(#1,MFUNC);}=0A | dclr '[' ']' {val=3Dadclr(#1,MARRAY,1);}=0A |=
 dclr '[' constant ']' {val=3Dadclr(#1,MARRAY,#3);}=0A | identifier {val=
=3Dadclr(0,0);}=0A | '(' dclr ')' {val=3D#2;}=0A=0A function_declarator:=
=0A '*' function_declarator {val=3Dadclr(#2,MPTR);}=0A | function_declar=
ator '(' ')' {val=3Dadclr(#1,MFUNC);}=0A | function_declarator '[' ']' {=
val=3Dadclr(#1,MARRAY,1);}=0A | function_declarator '[' constant ']' {va=
l=3Dadclr(#1,MARRAY,#3);}=0A | identifier '(' ')' {val=3Dadclr(adclr(0,0=
),MFUNC);=0A parml=3D0;}=0A | identifier '(' parameter_list ')' {val=3Da=
dclr(adclr(0,0),MFUNC);=0A parml=3D#3;}=0A | '(' function_declarator ')'=
 {val=3D#2;}=0A=0A parameter_list:=0A identifier {val=3Dpush(#1);}=0A |=
 parameter_list ',' identifier {push(#3);}=0A=0A formal_decl_list:=0A fo=
rmal_declaration=0A | formal_decl_list formal_declaration=0A=0A formal_d=
eclaration:=0A type_declaration=0A | REGISTER type_declaration=0A=0A typ=
e_decl_list:=0A type_declaration=0A | type_decl_list type_declaration=0A=
=0A type_declaration:=0A $type_specifier declarator_list ';' {in_type_de=
f=3D0;=0A val=3D#2;}=0A=0A $type_specifier:=0A type_specifier {in_type_d=
ef=3D1;=0A attrib(-1,#1);}=0A=0A # statements #=0A=0A statement_list:=0A=
 statement=0A | statement_list statement {val=3Dastmtl(#1,#2);}=0A=0A st=
atement:=0A expression ';' {val=3Daexprstmt(#1);}=0A | compound_statemen=
t=0A | IF '(' expression ')' statement {val=3Daif(#3,#5,0);}=0A | IF '('=
 expression ')' statement ELSE statement {val=3Daif(#3,#5,#7);}=0A | whi=
le '(' expression ')' statement {val=3Dawhile(#3,#5);}=0A | for '(' .exp=
ression ';' .expression ';' .expression ')' statement=0A {val=3Dafor(#3,=
#5,#7,#9);}=0A | do statement WHILE '(' expression ')' ';' {val=3Dado(#2=
,#5);}=0A | switch '(' expression ')' statement {val=3Daswitch(#3,#5);}=
=0A | CASE constant ':' statement {val=3Dacase(#2,#4);}=0A | DEFAULT ':'=
 statement {val=3Dadefault(#3);}=0A | BREAK ';' {val=3Dabreak();}=0A | C=
ONTINUE ';' {val=3Dacontinue();}=0A | RETURN ';' {val=3Dareturn(0);}=0A=
 | RETURN expression ';' {val=3Dareturn(#2);}=0A | GOTO lexpression ';'=
 {val=3Dagoto(#2);}=0A | identifier ':' statement {val=3Dalabel(#1,#3);}=
=0A | ENTRY identifier ':' statement {val=3Daentry(#2,#4);}=0A | ';' {va=
l=3Danull();} =0A=0A # expressions #=0A=0A .expression:=0A expression=0A=
 | {val=3D0;}=0A=0A expression_list:=0A expression =3D '=3D'=0A | expres=
sion_list ',' expression {val=3Daelist(#1,#3);}=0A=0A expression:=0A exp=
ression '*' expression {val=3Dnode(n_times,#1,#3);}=0A | expression '/'=
 expression {val=3Dnode(n_div,#1,#3);}=0A | expression '%' expression {v=
al=3Dnode(n_mod,#1,#3);}=0A | expression '+' expression {val=3Dnode(n_pl=
us,#1,#3);}=0A | expression '-' expression {val=3Dnode(n_minus,#1,#3);}=
=0A | expression '<<' expression {val=3Dnode(n_ls,#1,#3);}=0A | expressi=
on '>>' expression {val=3Dnode(n_rs,#1,#3);}=0A | expression '<' express=
ion {val=3Dnode(n_lt,#1,#3);}=0A | expression '>' expression {val=3Dnode=
(n_gt,#1,#3);}=0A | expression '<=3D' expression {val=3Dnode(n_le,#1,#3)=
;}=0A | expression '>=3D' expression {val=3Dnode(n_ge,#1,#3);}=0A | expr=
ession '=3D=3D' expression {val=3Dnode(n_eq,#1,#3);}=0A | expression '!=
=3D' expression {val=3Dnode(n_ne,#1,#3);}=0A | expression '&' expression=
 {val=3Dnode(n_band,#1,#3);}=0A | expression '^' expression {val=3Dnode(=
n_bxor,#1,#3);}=0A | expression '|' expression {val=3Dnode(n_bior,#1,#3)=
;}=0A | expression '&&' expression {val=3Dnode(n_tv_and,#1,#3);}=0A | ex=
pression '||' expression {val=3Dnode(n_tv_or,#1,#3);}=0A | expression '?=
' expression ':' expression=0A {val=3Dnode(n_qmark,#1,node(n_colon,#3,#5=
));}=0A | expression '=3D' expression {val=3Dnode(n_assign,#1,#3);}=0A |=
 expression '=3Dop' expression {val=3Dnode(n_ars+#2,#1,#3);}=0A | expres=
sion ',' expression {val=3Dnode(n_comma,#1,#3);}=0A | term =0A=0A # the=
 following productions are ordered very carefully so that the=0A desired=
 thing is done in the case of a R/R conflict #=0A=0A lexpression:=0A exp=
ression=0A | identifier {val=3Daidn(alidn(#1));}=0A=0A fterm:=0A term=0A=
 | identifier {val=3Daidn(afidn(#1));}=0A=0A type_identifier:=0A identif=
ier {val=3Datidn(#1);}=0A=0A term:=0A term '++' {val=3Dnode(n_inca,#1);}=
=0A | term '--' {val=3Dnode(n_deca,#1);}=0A | '*' term {val=3Dnode(n_sta=
r,#2);}=0A | '&' term {val=3Dnode(n_addr,#2);}=0A | '-' term {val=3Dnode=
(n_uminus,#2);}=0A | '!' term {val=3Dnode(n_tvnot,#2);}=0A | '~' term {v=
al=3Dnode(n_bnot,#2);}=0A | '++' term {val=3Dnode(n_incb,#2);}=0A | '--'=
 term {val=3Dnode(n_decb,#2);}=0A | SIZEOF term {val=3Dnode(n_sizeof,#2)=
;}=0A | SIZEOF '(' cast_type ')' =3D SIZEOF=0A {val=3Dnode(n_int,1);} #=
 hack #=0A | '(' cast_type ')' term =3D '++'=0A {val=3D#4;} # hack #=0A=
 | term '[' expression ']' {val=3Dasubscript(#1,#3);}=0A | fterm '(' exp=
ression_list ')' {val=3Dacall(#1,#3);}=0A | fterm '(' ')' {val=3Dacall(#=
1,0);}=0A | term '.' identifier {val=3Dadot(#1,#3);}=0A | term '->' iden=
tifier {val=3Daptr(#1,#3);}=0A | identifier {val=3Daidn(aeidn(#1));}=0A=
 | integer {val=3Dnode(n_int,#1);}=0A | floatcon {val=3Dnode(n_float,#1)=
;}=0A | string {val=3Dnode(n_string,#1);}=0A | '(' expression ')' {val=
=3D#2;}=0A=0A cast_type: literal_type_specifier null_decl=0A=0A null_dec=
l: # empty #=0A | '(' ')'=0A | '(' null_decl ')' '(' ')'=0A | '*' null_d=
ecl=0A | null_decl '[' ']'=0A | null_decl '[' constant ']'=0A | '(' null=
_decl ')'=0A=0A while: WHILE {apshw();}=0A do: DO {apshd();}=0A for: FOR=
 {apshf();}=0A switch: SWITCH {apshs();}=0A struct: STRUCT {strlev++;}=
=0A $identifier: identifier {val=3Dastridn(#1);}=0A begin: '{' {abegin()=
;}=0A end: '}' {aend();}=0A=0A constant:=0A constant '*' constant {val=
=3D#1*#3;}=0A | constant '/' constant {val=3D#1/#3;}=0A | constant '%' c=
onstant {val=3D#1%#3;}=0A | constant '+' constant {val=3D#1+#3;}=0A | co=
nstant '-' constant {val=3D#1-#3;}=0A | constant '<<' constant {val=3D#1=
<<#3;}=0A | constant '>>' constant {val=3D#1>>#3;}=0A | constant '<' con=
stant {val=3D#1<#3;}=0A | constant '>' constant {val=3D#1>#3;}=0A | cons=
tant '<=3D' constant {val=3D#1<=3D#3;}=0A | constant '>=3D' constant {va=
l=3D#1>=3D#3;}=0A | constant '=3D=3D' constant {val=3D#1=3D=3D#3;}=0A |=
 constant '!=3D' constant {val=3D#1!=3D#3;}=0A | constant '&' constant {=
val=3D#1}=0A | constant '^' constant {val=3D#1^#3;}=0A | constant '|' co=
nstant {val=3D#1|#3;}=0A | constant '&&' constant {val=3D#1&}=0A | const=
ant '||' constant {val=3D#1||#3;}=0A | constant '?' constant ':' constan=
t=0A {val=3D(#1?#3:#5);}=0A | c_term =0A=0A c_term:=0A '-' c_term {val=
=3D -#2;}=0A | '!' c_term {val=3D !#2;}=0A | '~' c_term {val=3D ~#2;}=0A=
 | integer=0A | '(' constant ')' {val=3D#2;}=0A=0A

--=_47dde88ae27961fafbc113e2e4a30cc6
Content-Type: text/html; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

<html><body style=3D"font-family: Helvetica,Arial,sans-serif; font-size:=
 12px;"><div>I don't recognize this as any Yacc that my hands have touch=
ed.=C2=A0=C2=A0=C2=A0 Looking at the reserved words,</div><div>there is=
 one, ENTRY, that I've never heard of (although FORTRAN had an ENTRY sta=
tement), <br></div><div>and there is STRUCT but no UNION.=C2=A0 Also, he=
 uses val=3D instead of $$=3D.=C2=A0 There don't seem to be <br></div><d=
iv>any nontrivial assignment ops (neither +=3D or =3D+).</div><div> <br>=
</div><div>Al was at Bell Labs in 1973, and this is dated 5 years later.=
</div><div><br></div><div>The use of quotes for single character literal=
s was in early Yaccs, but it led to some strange-looking <br></div><div>=
lexical analyzer code, and I quickly gave it up.</div><div><br></div><di=
v>I'm guessing either Al wrote it from scratch or based it on some other=
 similar program.=C2=A0 LR parsing</div><div>made quite a stir in the 70=
's.</div><div><br></div><div>Can't help you though as far as how to gene=
rate a parser from this input...</div><div><br></div><div>Steve<br></div=
><br><br><blockquote class=3D"atmailquote"><br>----- Original Message --=
---<br><div id=3D"origionalMessageFromField" style=3D"width:100%;display=
:inline;background:rgb(228,228,228);"><div style=3D"display:inline;font-=
weight:bold;">From:</div> "Lars Brinkhoff" &lt;lars@nocrew.org&gt;</div>=
<br><div id=3D"origionalMessageToField" style=3D"display:inline;font-wei=
ght:bold;">To:</div>&lt;tuhs@tuhs.org&gt;<br><div id=3D"origionalMessage=
SentField" style=3D"display:inline;font-weight:bold;">Cc:</div><br><div=
 style=3D"display:inline;font-weight:bold;">Sent:</div>Sun, 28 Oct 2018=
 21:34:49 +0000<br><div id=3D"origionalMessageSubjectField" style=3D"dis=
play:inline;font-weight:bold;">Subject:</div>[TUHS] Archaic yacc C gramm=
ar<br><br><br>=0AHello,<br><br>=0AThis is Alan Snyder's C grammar.  It's=
 supposedly for yacc, but it's<br>=0Aprobably using some really ancient=
 version.  Maybe from when Alan did a<br>=0Astint at Bell labs and conve=
rted yacc from B to C.<br><br>=0ADoes anyone recognize this type of yacc=
 input?  I don't have the<br>=0Acorresponding yacc version, and the one=
 in V6 isn't happy about this<br>=0Afile.  What would it take to update=
 the grammar for V6 yacc?  Add in<br>=0Asome %term, replace \\ with %%?<=
br><br><br><br>=0A=09#     C GRAMMAR     #<br>=0A=09#    28 May 1978   =
 #<br>=0A=09#    Alan Snyder    #<br><br><br>=0A#=0926 acceptable confli=
cts:<br><br>=0A=092 S/R conflicts for (parsing) ambiguity between<br>=0A=
=09=09declarators and function_declarators<br>=0A=091 S/R conflict for t=
he C ELSE ambiguity<br>=0A=094 R/R conflicts for the (parsing) problem w=
ith regard<br>=0A=09=09to integer constants as initial_values<br>=0A=091=
2 R/R conflicts for the (parsing) problem with regard<br>=0A=09=09to ide=
ntifiers in function calls<br>=0A=091 R/R conflict for the (parsing) pro=
blem with regard<br>=0A=09=09to identifiers in goto statements<br>=0A=09=
4 R/R conflicts and 1 S/R conflict for TYPEDEFs<br>=0A=091 S/R conflict=
 for ambiguous cast types<br>=0A=09=09(int ()) =3D (int x()) not (int (x=
))<br><br>=0A=09Approximate description:<br><br>=0A 18=09S/R=09(=09shift=
 37=09reduce 141<br>=0A 50=09S/R=09(=09shift 37=09reduce 71<br>=0A 81=09=
S/R=09(=09shift 37=09reduce 71<br>=0A113=09R/R=09(=09reduce 141=09reduce=
 140<br>=0A113=09R/R=09(=09reduce 159=09reduce 140<br>=0A113=09R/R=09*=
=09reduce 159=09reduce 141<br>=0A113=09S/R=09:=09shift 199=09reduce 141<=
br>=0A183=09R/R=09,=09reduce 203=09reduce 24<br>=0A183=09R/R=09}=09reduc=
e 203=09reduce 24<br>=0A204=09R/R=09(=09reduce 159=09reduce 140<br>=0A20=
6=09R/R=09(=09reduce 148=09reduce 139<br>=0A207=09R/R=09(=09reduce 147=
=09reduce 139<br>=0A208=09R/R=09(=09reduce 145=09reduce 139<br>=0A209=09=
R/R=09(=09reduce 144=09reduce 139<br>=0A210=09R/R=09(=09reduce 146=09red=
uce 139<br>=0A211=09R/R=09(=09reduce 149=09reduce 139<br>=0A212=09R/R=09=
(=09reduce 150=09reduce 139<br>=0A215=09R/R=09(=09reduce 159=09reduce 14=
0<br>=0A215=09R/R=09;=09reduce 159=09reduce 138<br>=0A225=09R/R=09(=09re=
duce 151=09reduce 139<br>=0A228=09R/R=09(=09reduce 159=09reduce 140<br>=
=0A284=09R/R=09,=09reduce 203=09reduce 25<br>=0A284=09R/R=09}=09reduce 2=
03=09reduce 25<br>=0A291=09S/R=09)=09shift 339=09reduce 165<br>=0A343=09=
R/R=09(=09reduce 153=09reduce 139<br>=0A360=09S/R=09ELSE=09shift 369=09r=
educe 94<br><br>=0A#<br><br>=0A=09#     terminal symbols     #<br><br>=
=0A';' '}' '{' ']' '[' ')' '(' ':'<br>=0A',' '.' '?' '~' '!' '&amp;' '|'=
 '^'<br>=0A'%' '/' '*' '-' '+' '=3D' '&lt;' '&gt;'<br>=0A'++' '--' '=3D=
=3D' '!=3D' '&lt;=3D' '&gt;=3D' '&lt;&lt;' '&gt;&gt;'<br>=0A'-&gt;' '=3D=
op' '&amp;&amp;' '||' 'c'<br>=0AINT CHAR FLOAT DOUBLE STRUCT AUTO STATIC=
<br>=0AEXTERN RETURN GOTO IF ELSE SWITCH<br>=0ABREAK CONTINUE WHILE DO F=
OR DEFAULT CASE<br>=0AENTRY REGISTER SIZEOF LONG SHORT UNSIGNED TYPEDEF=
 'l'<br>=0A'm' 'n' 'o' 'p' 'q' 'r' 's'<br>=0Aidentifier integer floatcon=
 string<br><br>=0A=09#     precedence information     #<br><br>=0A\&lt;=
 ','<br>=0A\&gt; '=3D' '=3Dop'<br>=0A\&gt; '?' ':'<br>=0A\&lt; '||'<br>=
=0A\&lt; '&amp;&amp;'<br>=0A\&lt; '|'<br>=0A\&lt; '^'<br>=0A\&lt; '&amp;=
'<br>=0A\&lt; '=3D=3D' '!=3D'<br>=0A\&lt; '&lt;' '&gt;' '&lt;=3D' '&gt;=
=3D'<br>=0A\&lt; '&lt;&lt;' '&gt;&gt;'<br>=0A\&lt; '+' '-'<br>=0A\&lt; '=
*' '/' '%'<br>=0A\&gt; '!' '~'<br>=0A\&gt; '++' '--' SIZEOF<br>=0A\&lt;=
 '[' '(' '.' '-&gt;'<br><br>=0A\\<br><br>=0A=09#     external definition=
s     #<br><br>=0Aprogram:<br>=0A=09  program external_definition<br>=0A=
=09|<br><br>=0Aexternal_definition:<br>=0A=09  declaration<br>=0A=09| fu=
nction_definition<br><br>=0Afunction_definition:<br>=0A=09  function_spe=
cification function_body=09=09{afdef(#1,#2);}<br><br>=0Afunction_specifi=
cation:<br>=0A=09  decl_specifiers function_declarator=09=09{val=3Dafdcl=
(1);}<br>=0A=09| function_declarator=09=09=09=09{val=3Dafdcl(0);}<br><br=
>=0Afunction_body:<br>=0A=09  formal_declarations compound_statement=09{=
val=3D#2;}<br><br>=0Aformal_declarations:<br>=0A=09  formal_decl_list=09=
=09=09=09{afpdcl();}<br>=0A=09| =09=09=09=09=09=09{afpdcl();}<br><br>=0A=
compound_statement:<br>=0A=09  begin declaration_list statement_list end=
=09{val=3D#3;}<br>=0A=09| begin statement_list end=09=09=09{val=3D#2;}<b=
r><br>=0Ainit_declarator_list:<br>=0A=09  init_declarator<br>=0A=09| ini=
t_declarator_list ',' init_declarator <br><br>=0Ainit_declarator:<br>=0A=
=09  $declarator initializer=09=09{aidecl();}<br>=0A=09| declarator=09=
=09=09=09{aidecl();}<br>=0A=09| function_declarator=09=09=09{adeclr(makt=
yp());}<br><br>=0Ainitializer:<br>=0A=09  initial_value<br>=0A=09| '{' i=
nitial_value_expression_list '}'<br>=0A=09| '{' initial_value_expression=
_list ',' '}'<br><br>=0Ainitial_value_expression_list:<br>=0A=09  initia=
l_value_expression<br>=0A=09| initial_value_expression_list ',' initial_=
value_expression<br><br>=0Ainitial_value:<br>=0A=09  integer=09=09=09=09=
{inz(i_int,#1);}<br>=0A=09| '-' integer=09=09=09=09{inz(i_int,-#2);}<br>=
=0A=09| floatcon=09=09=09=09{inz(i_float,#1);}<br>=0A=09| '-' floatcon=
=09=09=09=09{inz(i_negfloat,#2);}<br>=0A=09| identifier=09=09=09=09{inz(=
i_idn,#1);}<br>=0A=09| '&amp;' identifier=09=09=09{inz(i_idn,#2);}<br>=
=0A=09| string =09=09=09=09{inz(i_string,#1);}<br><br>=0Ainitial_value_e=
xpression:<br>=0A=09  constant=09=09=09=09{inz(i_int,#1);}<br>=0A=09| in=
itial_value<br><br>=0A=09#     declarations     #<br><br>=0Adeclaration_=
list:<br>=0A=09  declaration<br>=0A=09| declaration_list declaration<br>=
<br>=0Adeclaration:<br>=0A=09  decl_specifiers init_declarator_list ';'<=
br>=0A=09| literal_type_specifier ';'<br><br>=0Adecl_specifiers:<br>=0A=
=09  type_specifier=09=09=09{attrib(-1,#1);}<br>=0A=09| sc_specifier typ=
e_specifier=09=09{attrib(#1,#2);}<br>=0A=09| type_specifier sc_specifier=
=09=09{attrib(#2,#1);}<br><br>=0Atype_specifier:<br>=0A=09  type_identif=
ier<br>=0A=09| literal_type_specifier<br><br>=0Aliteral_type_specifier:<=
br>=0A=09  INT=09=09=09=09=09{val=3DTINT;}<br>=0A=09| CHAR=09=09=09=09=
=09{val=3DTCHAR;}<br>=0A=09| FLOAT=09=09=09=09=09{val=3DTFLOAT;}<br>=0A=
=09| DOUBLE=09=09=09=09{val=3DTDOUBLE;}<br>=0A=09| LONG=09=09=09=09=09{v=
al=3DTINT;}<br>=0A=09| LONG INT=09=09=09=09{val=3DTINT;}<br>=0A=09| SHOR=
T=09=09=09=09=09{val=3DTINT;}<br>=0A=09| SHORT INT=09=09=09=09{val=3DTIN=
T;}<br>=0A=09| LONG FLOAT=09=09=09=09{val=3DTDOUBLE;}<br>=0A=09| UNSIGNE=
D=09=09=09=09{val=3DTINT;}<br>=0A=09| UNSIGNED INT=09=09=09=09{val=3DTIN=
T;}<br>=0A=09| struct '{' type_decl_list '}'=09=09=09{val=3Dastruct(NULL=
,#3);}<br>=0A=09| struct $identifier '{' type_decl_list '}'=09{val=3Dast=
ruct(#2,#4);}<br>=0A=09| struct identifier=09 =09=09=09{val=3Daostruct(#=
2);}<br><br>=0Asc_specifier:<br>=0A=09  AUTO=09=09=09=09=09{val=3Dc_auto=
;}<br>=0A=09| STATIC=09=09=09=09{val=3Dc_static;}<br>=0A=09| EXTERN=09=
=09=09=09{val=3Dc_extern;}<br>=0A=09| REGISTER=09=09=09=09{val=3Dc_auto;=
}<br>=0A=09| TYPEDEF=09=09=09=09{val=3Dc_typedef;}<br><br>=0Adeclarator_=
list:<br>=0A=09  declarator<br>=0A=09| declarator_list ',' declarator <b=
r><br>=0Adeclarator:<br>=0A=09  dclr=09=09=09=09=09{val=3Dadeclr(maktyp(=
));}<br>=0A=09| identifier ':' constant=09=09{val=3Dadeclr(afield(#1,#3)=
);}<br>=0A=09| ':' constant=09=09=09=09{val=3Dadeclr(afield(-1,#2));}<br=
><br>=0A$declarator:<br>=0A=09  dclr=09=09=09=09=09{aiinz(adeclr(maktyp(=
)));}<br><br>=0Adclr:<br>=0A=09'*' dclr=09=09=09=09{val=3Dadclr(#2,MPTR)=
;}<br>=0A=09| dclr '(' ')'=09=09=09=09{val=3Dadclr(#1,MFUNC);}<br>=0A=09=
| dclr '[' ']'=09=09=09=09{val=3Dadclr(#1,MARRAY,1);}<br>=0A=09| dclr '[=
' constant ']'=09=09=09{val=3Dadclr(#1,MARRAY,#3);}<br>=0A=09| identifie=
r  =09=09=09=09{val=3Dadclr(0,0);}<br>=0A=09| '(' dclr ')' =09=09=09=09{=
val=3D#2;}<br><br>=0Afunction_declarator:<br>=0A=09  '*' function_declar=
ator=09=09{val=3Dadclr(#2,MPTR);}<br>=0A=09| function_declarator '(' ')'=
=09=09{val=3Dadclr(#1,MFUNC);}<br>=0A=09| function_declarator '[' ']'=09=
=09{val=3Dadclr(#1,MARRAY,1);}<br>=0A=09| function_declarator '[' consta=
nt ']'=09{val=3Dadclr(#1,MARRAY,#3);}<br>=0A=09| identifier '(' ')'=09=
=09=09{val=3Dadclr(adclr(0,0),MFUNC);<br>=0A=09=09=09=09=09=09=09parml=
=3D0;}<br>=0A=09| identifier '(' parameter_list ')'=09{val=3Dadclr(adclr=
(0,0),MFUNC);<br>=0A=09=09=09=09=09=09=09parml=3D#3;}<br>=0A=09| '(' fun=
ction_declarator ')'=09=09{val=3D#2;}<br><br>=0Aparameter_list:<br>=0A=
=09  identifier=09=09=09=09{val=3Dpush(#1);}<br>=0A=09| parameter_list '=
,' identifier=09=09{push(#3);}<br><br>=0Aformal_decl_list:<br>=0A=09  fo=
rmal_declaration<br>=0A=09| formal_decl_list formal_declaration<br><br>=
=0Aformal_declaration:<br>=0A=09  type_declaration<br>=0A=09| REGISTER t=
ype_declaration<br><br>=0Atype_decl_list:<br>=0A=09  type_declaration<br=
>=0A=09| type_decl_list type_declaration<br><br>=0Atype_declaration:<br>=
=0A=09  $type_specifier declarator_list ';'=09{in_type_def=3D0;<br>=0A=
=09=09=09=09=09=09val=3D#2;}<br><br>=0A$type_specifier:<br>=0A=09  type_=
specifier=09=09=09{in_type_def=3D1;<br>=0A=09=09=09=09=09=09attrib(-1,#1=
);}<br><br>=0A=09#     statements     #<br><br>=0Astatement_list:<br>=0A=
=09  statement<br>=0A=09| statement_list statement=09=09{val=3Dastmtl(#1=
,#2);}<br><br>=0Astatement:<br>=0A=09  expression  ';'=09=09=09=09=09{va=
l=3Daexprstmt(#1);}<br>=0A=09| compound_statement<br>=0A=09| IF '(' expr=
ession ')' statement=09 =09=09{val=3Daif(#3,#5,0);}<br>=0A=09| IF '(' ex=
pression ')' statement ELSE statement=09{val=3Daif(#3,#5,#7);}<br>=0A=09=
| while '(' expression ')' statement=09 =09=09{val=3Dawhile(#3,#5);}<br>=
=0A=09| for '(' .expression ';' .expression ';' .expression ')' statemen=
t<br>=0A=09=09=09=09=09=09=09=09{val=3Dafor(#3,#5,#7,#9);}<br>=0A=09| do=
 statement WHILE '(' expression ')' ';'=09=09{val=3Dado(#2,#5);}<br>=0A=
=09| switch '(' expression ')' statement=09=09=09{val=3Daswitch(#3,#5);}=
<br>=0A=09| CASE constant ':' statement=09=09=09=09{val=3Dacase(#2,#4);}=
<br>=0A=09| DEFAULT ':' statement=09=09=09=09=09{val=3Dadefault(#3);}<br=
>=0A=09| BREAK ';'=09=09=09=09=09=09{val=3Dabreak();}<br>=0A=09| CONTINU=
E ';'=09=09=09=09=09=09{val=3Dacontinue();}<br>=0A=09| RETURN ';'=09=09=
=09=09=09=09{val=3Dareturn(0);}<br>=0A=09| RETURN expression ';'=09=09=
=09=09=09{val=3Dareturn(#2);}<br>=0A=09| GOTO lexpression ';'=09=09=09=
=09=09{val=3Dagoto(#2);}<br>=0A=09| identifier ':' statement=09=09=09=09=
{val=3Dalabel(#1,#3);}<br>=0A=09| ENTRY identifier ':' statement=09=09=
=09{val=3Daentry(#2,#4);}<br>=0A=09| ';' =09=09=09=09=09=09=09{val=3Danu=
ll();} <br><br><br>=0A=09#     expressions     #<br><br>=0A.expression:<=
br>=0A=09  expression<br>=0A=09|=09=09=09{val=3D0;}<br><br>=0Aexpression=
_list:<br>=0A=09  expression=09\=3D '=3D'<br>=0A=09| expression_list ','=
 expression =09=09{val=3Daelist(#1,#3);}<br><br>=0Aexpression:<br>=0A=09=
  expression '*' expression=09=09{val=3Dnode(n_times,#1,#3);}<br>=0A=09|=
 expression '/' expression=09=09{val=3Dnode(n_div,#1,#3);}<br>=0A=09| ex=
pression '%' expression=09=09{val=3Dnode(n_mod,#1,#3);}<br>=0A=09| expre=
ssion '+' expression=09=09{val=3Dnode(n_plus,#1,#3);}<br>=0A=09| express=
ion '-' expression=09=09{val=3Dnode(n_minus,#1,#3);}<br>=0A=09| expressi=
on '&lt;&lt;' expression=09=09{val=3Dnode(n_ls,#1,#3);}<br>=0A=09| expre=
ssion '&gt;&gt;' expression=09=09{val=3Dnode(n_rs,#1,#3);}<br>=0A=09| ex=
pression '&lt;' expression=09=09{val=3Dnode(n_lt,#1,#3);}<br>=0A=09| exp=
ression '&gt;' expression=09=09{val=3Dnode(n_gt,#1,#3);}<br>=0A=09| expr=
ession '&lt;=3D' expression=09=09{val=3Dnode(n_le,#1,#3);}<br>=0A=09| ex=
pression '&gt;=3D'  expression=09=09{val=3Dnode(n_ge,#1,#3);}<br>=0A=09|=
 expression '=3D=3D'  expression=09=09{val=3Dnode(n_eq,#1,#3);}<br>=0A=
=09| expression '!=3D'  expression=09=09{val=3Dnode(n_ne,#1,#3);}<br>=0A=
=09| expression '&amp;' expression=09=09{val=3Dnode(n_band,#1,#3);}<br>=
=0A=09| expression '^' expression=09=09{val=3Dnode(n_bxor,#1,#3);}<br>=
=0A=09| expression '|' expression=09=09{val=3Dnode(n_bior,#1,#3);}<br>=
=0A=09| expression '&amp;&amp;' expression=09=09{val=3Dnode(n_tv_and,#1,=
#3);}<br>=0A=09| expression '||' expression=09=09{val=3Dnode(n_tv_or,#1,=
#3);}<br>=0A=09| expression '?' expression ':' expression<br>=0A=09=09=
=09=09{val=3Dnode(n_qmark,#1,node(n_colon,#3,#5));}<br>=0A=09| expressio=
n '=3D' expression=09=09{val=3Dnode(n_assign,#1,#3);}<br>=0A=09| express=
ion '=3Dop' expression=09=09{val=3Dnode(n_ars+#2,#1,#3);}<br>=0A=09| exp=
ression ',' expression=09=09{val=3Dnode(n_comma,#1,#3);}<br>=0A=09| term=
 <br><br>=0A# the following productions are ordered very carefully so th=
at the<br>=0A  desired thing is done in the case of a R/R conflict #<br>=
<br>=0Alexpression:<br>=0A=09  expression<br>=0A=09| identifier=09=09=09=
{val=3Daidn(alidn(#1));}<br><br>=0Afterm:<br>=0A=09  term<br>=0A=09| ide=
ntifier=09=09=09{val=3Daidn(afidn(#1));}<br><br>=0Atype_identifier:<br>=
=0A=09  identifier=09=09=09{val=3Datidn(#1);}<br><br>=0Aterm:<br>=0A=09=
  term '++'=09=09=09{val=3Dnode(n_inca,#1);}<br>=0A=09| term '--'=09=09=
=09{val=3Dnode(n_deca,#1);}<br>=0A=09| '*' term=09=09=09{val=3Dnode(n_st=
ar,#2);}<br>=0A=09| '&amp;' term=09=09=09{val=3Dnode(n_addr,#2);}<br>=0A=
=09| '-' term=09=09=09{val=3Dnode(n_uminus,#2);}<br>=0A=09| '!' term=09=
=09=09{val=3Dnode(n_tvnot,#2);}<br>=0A=09| '~' term=09=09=09{val=3Dnode(=
n_bnot,#2);}<br>=0A=09| '++' term=09=09=09{val=3Dnode(n_incb,#2);}<br>=
=0A=09| '--' term=09=09=09{val=3Dnode(n_decb,#2);}<br>=0A=09| SIZEOF ter=
m=09=09=09{val=3Dnode(n_sizeof,#2);}<br>=0A=09| SIZEOF '(' cast_type ')'=
 \=3D SIZEOF<br>=0A=09=09=09=09=09{val=3Dnode(n_int,1);} # hack #<br>=0A=
=09| '(' cast_type ')' term \=3D '++'<br>=0A=09=09=09=09=09{val=3D#4;} #=
 hack #<br>=0A=09| term '[' expression ']'=09{val=3Dasubscript(#1,#3);}<=
br>=0A=09| fterm '(' expression_list ')'=09{val=3Dacall(#1,#3);}<br>=0A=
=09| fterm '(' ')'=09=09=09{val=3Dacall(#1,0);}<br>=0A=09| term '.' iden=
tifier=09=09{val=3Dadot(#1,#3);}<br>=0A=09| term '-&gt;' identifier=09=
=09{val=3Daptr(#1,#3);}<br>=0A=09| identifier=09=09=09{val=3Daidn(aeidn(=
#1));}<br>=0A=09| integer=09=09=09{val=3Dnode(n_int,#1);}<br>=0A=09| flo=
atcon=09=09=09{val=3Dnode(n_float,#1);}<br>=0A=09| string=09=09=09{val=
=3Dnode(n_string,#1);}<br>=0A=09| '(' expression ')' =09=09{val=3D#2;}<b=
r><br>=0Acast_type:=09   literal_type_specifier null_decl<br><br>=0Anull=
_decl:=09   # empty #<br>=0A=09=09|  '(' ')'<br>=0A=09=09|  '(' null_dec=
l ')' '(' ')'<br>=0A=09=09|  '*' null_decl<br>=0A=09=09|  null_decl '['=
 ']'<br>=0A=09=09|  null_decl '[' constant ']'<br>=0A=09=09|  '(' null_d=
ecl ')'<br><br>=0Awhile:=09=09  WHILE=09=09=09{apshw();}<br>=0Ado:=09=09=
  DO=09=09=09{apshd();}<br>=0Afor:=09=09  FOR=09=09=09{apshf();}<br>=0As=
witch:=09=09  SWITCH=09=09{apshs();}<br>=0Astruct:=09=09  STRUCT=09=09{s=
trlev++;}<br>=0A$identifier:=09  identifier=09=09{val=3Dastridn(#1);}<br=
>=0Abegin:=09=09  '{'=09=09=09{abegin();}<br>=0Aend:=09=09  '}'=09=09=09=
{aend();}<br><br>=0Aconstant:<br>=0A=09  constant '*' constant=09=09{val=
=3D#1*#3;}<br>=0A=09| constant '/' constant=09=09{val=3D#1/#3;}<br>=0A=
=09| constant '%' constant=09=09{val=3D#1%#3;}<br>=0A=09| constant '+' c=
onstant=09=09{val=3D#1+#3;}<br>=0A=09| constant '-' constant=09=09{val=
=3D#1-#3;}<br>=0A=09| constant '&lt;&lt;' constant=09{val=3D#1&lt;&lt;#3=
;}<br>=0A=09| constant '&gt;&gt;' constant=09{val=3D#1&gt;&gt;#3;}<br>=
=0A=09| constant '&lt;' constant=09=09{val=3D#1&lt;#3;}<br>=0A=09| const=
ant '&gt;' constant=09=09{val=3D#1&gt;#3;}<br>=0A=09| constant '&lt;=3D'=
 constant=09{val=3D#1&lt;=3D#3;}<br>=0A=09| constant '&gt;=3D'  constant=
=09{val=3D#1&gt;=3D#3;}<br>=0A=09| constant '=3D=3D'  constant=09{val=3D=
#1=3D=3D#3;}<br>=0A=09| constant '!=3D'  constant=09{val=3D#1!=3D#3;}<br=
>=0A=09| constant '&amp;' constant=09=09{val=3D#1&amp;#3;}<br>=0A=09| co=
nstant '^' constant=09=09{val=3D#1^#3;}<br>=0A=09| constant '|' constant=
=09=09{val=3D#1|#3;}<br>=0A=09| constant '&amp;&amp;' constant=09{val=3D=
#1&amp;&amp;#3;}<br>=0A=09| constant '||' constant=09{val=3D#1||#3;}<br>=
=0A=09| constant '?' constant ':' constant<br>=0A=09=09=09=09=09{val=3D(=
#1?#3:#5);}<br>=0A=09| c_term <br><br>=0Ac_term:<br>=0A=09  '-' c_term=
=09=09{val=3D -#2;}<br>=0A=09| '!' c_term=09=09{val=3D !#2;}<br>=0A=09|=
 '~' c_term=09=09{val=3D ~#2;}<br>=0A=09| integer<br>=0A=09| '(' constan=
t ')'=09{val=3D#2;}<br><br></blockquote></body></html>

--=_47dde88ae27961fafbc113e2e4a30cc6--

