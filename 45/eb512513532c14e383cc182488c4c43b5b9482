From: peter.jeremy@alcatel.com.au (Peter Jeremy)
Date: Tue, 10 Sep 2002 07:17:10 +1000
Subject: [pups] Bringing up the fist C compiler
In-Reply-To: <3D77823A.1050504@pacbell.net>
References: <Pine.LNX.4.21.0209051350370.4341-100000@Tempo.Update.UU.SE> <3D77823A.1050504@pacbell.net>
Message-ID: <20020909211710.GA87874@gsmx07.alcatel.com.au>

On 2002-Sep-05 09:11:38 -0700, Michael Davidson <MichaelDavidson at pacbell.net> wrote:
>Johnny Billquist wrote:
>>But even though I cannot account for all steps, I can guarantee that at
>>the end of the chain, you *will* find assembler.
>
>Or, just possibly, Alan Turing hand punching Mark 1 machine code onto
>paper tape ;-)

Actually, to use one of the other "first stored-program computer"
candidates, EDSAC provided what I consider to be a very sophisticated
assembler/loader that read programs off paper tape into memory.  This
assembler/loader ("initial orders") was 41 instructions long and was
hard-wired onto uniselectors which were automatically loaded into
memory when the start switch was pressed.

It supported:
- single-letter mnemonics for each of the 18 instructions
- decimal entry of numbers (EDSAC was binary internally)
- 13 single-letter variables which could be assigned or added to the
  address in each instruction.
- program relocation (courtesy of the above)

Overall, the input language looks much closer to assembler language
than the instruction bit patterns in memory.  (The Mathematical
Laboratory also developed an extensive collection of reusable
subroutines intended to simplify program development).

Ref: "The Preparation of Programs for an Electronic Digital Computer",
   M.V. Wilkes, D.J. Wheeler, S. Gill, Addison-Wesley, 1951.

A rummage around on the WEB will turn up a couple of EDSAC simulators
and sample programs.

Peter


