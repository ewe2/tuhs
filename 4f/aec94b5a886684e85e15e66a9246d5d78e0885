From: ggm@algebras.org (George Michaelson)
Date: Fri, 16 Feb 2018 11:55:48 +1000
Subject: [TUHS] Happy birthday, Niklaus Wirth!
In-Reply-To: <20180216011815.GD8295@mcvoy.com>
References: <alpine.BSF.2.21.1802150801090.5573@aneurin.horsfall.org>
 <d718364c-87f4-280e-9bcc-9753493a75a5@telegraphics.com.au>
 <alpine.BSF.2.21.1802161058010.798@aneurin.horsfall.org>
 <CAEoi9W51rVASfMjMrK8RhPorWuPNmUa7YYg0Oy56pF6hVaV4Cg@mail.gmail.com>
 <20180216011815.GD8295@mcvoy.com>
Message-ID: <CAKr6gn3L0qVffact2ZXyxEhjz6+N2KT5N0S4o-pmcdrnNbfpYg@mail.gmail.com>

syntactically, semantically, a lot of the strongly typed functional
programming outcomes have roots into ideas explored in the LISP
family.

the quants are using it heavily. The declarative, checked-at-compile
qualities reduce errors, the statements have some authority and the
formulaic expression of things as compositions over functions works
for their brains. the typing wasn't strong in LISP but the FP
expressive quality and lazy eval was. Sure, it was in Algol family
languages too, but I think it got sort-of left out when C hit the
road.

I struggle with FP. I have major envy of minds which can think like
that.  I wish I had that kind of mind. I sit with someone who does. He
front loads his problems with type statements and produces terse but
very efficient code. Its a marketable skill in the right place.

I think you're right its not very system-y but the lines are blurring.
Go introduces the need for GC. Once you need GC, you enter a door
where all the things we said we didn't do pop back into view,
including lazy evaluation which is in the foundation of FP, and ..
LISP. So for the set of problems which people say "coded in GO" you
can think "hmm: maybe GHC with the right frobs would work there"

Rust apparently doesn't do GC. So maybe its more in the 'not in my
world' camp. Syntactically Go is of course nothing LIKE an FP as I
understand it, but then I can't program functionally, so I don't
entirely know what I know any more here.

On Fri, Feb 16, 2018 at 11:18 AM, Larry McVoy <lm at mcvoy.com> wrote:
> On Thu, Feb 15, 2018 at 07:51:14PM -0500, Dan Cross wrote:
>> >> Worth mentioning one significant exception: the Lisp family.
>>
>> So anyway...some of you who were there, was there cross-pollination? Was
>> Franz Lisp a thing Unix people at Berkeley played with, or was it mostly
>> Lisp people who just happened to be using Unix because VAXen were expensive?
>
> This is just my opinion so there is a grain of salt.  Or a salt shaker.
>
> I think there are two (at least) sorts of programmers, the systems people
> and the lisp people.  Sometimes you get both kinds in the same person
> but that tends to be rare (and awesome, I've employeed several of those,
> they were magic).
>
> I'm a systems guy.  I've played with lisp, even wrote a tiny lisp (haven't
> we all?), tried to get to like it and utterly failed.  All sorts of smart
> people I knew in my career loved lisp, sneered at any other language,
> tended to think in ASTs, etc, etc.  I definitely felt inferior and tried
> to like lisp but just never got what was so neat about it.
>
> For good reason, I think.  Nobody has written a serious operating system,
> or a serious $BIG_PROJECT in Lisp.  Not one that has been commercially
> successful, so far as I know.  I know there were attempts but all those
> attempts failed.  Why?  Performance I think.  C performs far better even
> though it is, in the eyes of lisp people, far more awkward to do things.
>
> I can't tell you the number of times I've heard "If we were using Lisp
> we'd be done by now".  100's, 1000's.  What I have never heard is "I
> recoded this pile of C in lisp and it's 10x faster".
>
> I think the thing is that lisp programmers were optimizing for speed
> of coding and C programmers were optimizing for speed of execution.
>
> So I suspect that Franz Lisp was mostly lisp people who happened to be
> using Unix.  But I wasn't at Berkeley so what do I know?
>
> --lm

