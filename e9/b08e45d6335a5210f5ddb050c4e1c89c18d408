From: luvisi@gmail.com (Andru Luvisi)
Date: Fri, 14 Oct 2011 21:57:35 -0700
Subject: [TUHS] b remnants?
In-Reply-To: <CAFCBnZtX8s+s5gXJG+3N7bhjd7iQ42Lrwt-7mKv=1AsUDsXPng@mail.gmail.com>
References: <CAFCBnZv9vWOwYL2Nxwpr_s0JvFsV1nfg59p7zppani7OjNPWAw@mail.gmail.com>
	<CAFCBnZtX8s+s5gXJG+3N7bhjd7iQ42Lrwt-7mKv=1AsUDsXPng@mail.gmail.com>
Message-ID: <CAObyg6YdLJSdyTw74o+mPCmm_EmFY7mM3xU1fB_AgOpaTT3jiQ@mail.gmail.com>

On Fri, Oct 14, 2011 at 8:57 PM, A. P. Garcia
<a.phillip.garcia at gmail.com> wrote:
> What intrigued me about this is that it's such an early example of an
> abstract machine running as an interpreter.

For what it's worth, an abstract machine based implementation for
Algol 60 was published in 1964 in the book "Algol 60 Implementation"
by Randell and Russell.  It gives flowcharts, not source code.  I seem
to recall the book saying that a couple of different implementations
has been built from the same set of flowcharts.

If you're willing to count abstract machines meant for human use,
rather than as a compiler target, there was a floating point
"interpretive routine" for the EDSAC by 1951.  See the first edition
of "The Preparation of Programs for an Electronic Digital Computer" by
Wilkes, Wheeler, and Gill (though I think I remember seeing somewhere
that they had it by 1949, but I can't find the reference right now).
The idea being that you would run the "interpretive routine" and it
would run a bunch of instructions for a virtual machine that had
floating point support.

Andru


