From: bakul@bitblocks.com (Bakul Shah)
Date: Fri, 16 Feb 2018 05:34:56 -0800
Subject: [TUHS] Happy birthday, Niklaus Wirth!
In-Reply-To: Your message of "Fri, 16 Feb 2018 12:37:39 +0000."
 <3A4DF9EC-F287-4CD9-85E8-21EE729B37ED@tfeb.org>
References: <alpine.BSF.2.21.1802150801090.5573@aneurin.horsfall.org>
 <d718364c-87f4-280e-9bcc-9753493a75a5@telegraphics.com.au>
 <alpine.BSF.2.21.1802161058010.798@aneurin.horsfall.org>
 <CAEoi9W51rVASfMjMrK8RhPorWuPNmUa7YYg0Oy56pF6hVaV4Cg@mail.gmail.com>
 <20180216020944.AF0ED156E80B@mail.bitblocks.com>
 <98310912-009A-438C-B7C6-82C8DF25621B@tfeb.org>
 <20180216121102.0DFC2156E80B@mail.bitblocks.com>
 <3A4DF9EC-F287-4CD9-85E8-21EE729B37ED@tfeb.org>
Message-ID: <20180216133512.24B19156E811@mail.bitblocks.com>

On Fri, 16 Feb 2018 12:37:39 +0000 tfb at tfeb.org wrote:
tfb at tfeb.org writes:
> 
> On 16 Feb 2018, at 12:10, Bakul Shah <bakul at bitblocks.com> wrote:
> >=20
> > Now you may quibble about "came from"=20
> 
> I do so quibble.  In particular I quibble that features *that were not
> present in Algol*, such as full continuations (which I think exist in
> the AIM-349 language via CATCH) can have 'come from Algol'.  Full
> continuations are the place where Scheme actually takes lexical scope
> seriously.

They did lexical scoping "right", no doubt. But back when
Landin first found that lambda calculus was useful for
modeling programming languages these concepts were not clearly
understood.  I do not recall reading anything about whether
Algol designers not allowing full lexical scopin was due to an
oversight or realizing that efficient implementation of
functional argument was not possible. May be Algol's call by
name was deemed sufficient? At any rate Algol's not having
full lexical scoping does not mean one can simply reject the
idea of being influenced by it. Often at the start there is
lots of fumbling before people get it right. May be someone
should ask Steele?

And no, I do not think first class continuations automatically
follow from lexical scoping.  Go has lexical scoping including
closures but no call/cc.  The idea of representing future
program state as a function I think comes from Strachey,
Wadsworth and Reynolds. They used it extensively in
denotational semantics to model program behavior.

> But I'm not interested in getting into a fight about this.

We are just presenting our interpretation of history!  Not
that anybody cares!

